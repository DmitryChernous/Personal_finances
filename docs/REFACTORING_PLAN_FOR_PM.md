# План рефакторинга и улучшения проекта «Учёт личных финансов»

**Дата:** 31 января 2026  
**Назначение:** Документ для передачи продакт-менеджеру и команде разработки.  
**Статус:** Анализ завершён; изменения в код не вносились.

---

## 1. Краткое резюме

Прототип проекта по учёту личных финансов на Google Apps Script (clasp) в целом соответствует заявленным целям: сбор данных с разных счетов, подготовка к анализу, дашборды и отчёты. В коде из-за многократных переделок накопились **несогласованности, мёртвый код, потенциальные логические ошибки и места для оптимизации**. Ниже — структурированный анализ и пошаговый план рефакторинга без внесения изменений в код.

---

## 2. Обзор структуры проекта

### 2.1. Исходный код (src/)

| Группа | Файлы | Назначение |
|--------|--------|------------|
| Точка входа | Code.js | onOpen, onEdit, меню, вызовы основных действий |
| Схема и константы | Schema.js, Constants.js | Схемы листов, статусы, типы, лимиты |
| Локализация и листы | I18n.js, Sheets.js, Setup.js, Settings.js | Ключи листов, i18n, поиск/создание листов, настройки |
| Транзакции и данные | RawSheets.js, Import.js, ImportCsv.js, ImportSberbank.js, ImportPdf*.js | Синхронизация raw, импорт CSV/PDF, дедупликация |
| Валидация и ошибки | Validation.js, ErrorHandler.js | Валидация строк, подсветка ошибок, логирование |
| Аналитика | Dashboard.js, Reports.js, Budgets.js, CategoryRules.js, RecurringTransactions.js | Дашборд, отчёты, бюджеты, правила категорий, регулярные платежи |
| Вспомогательные | DateUtils.js, Export.js, Archive.js, QuickEntry.js, Search.js, Help.js, Template.js, DemoData.js, TestData.js, Tests.js | Утилиты дат, экспорт, архивирование, UI, тесты |

### 2.2. Зависимости между модулями

- **Code.js** зависит от I18n, Constants, Schema (через ключи листов), Validation, RawSheets, Import, и т.д.
- **RawSheets.js** использует Schema (PF_TRANSACTIONS_SCHEMA), I18n (PF_SHEET_KEYS), Settings (pfGetSetting_, PF_SETUP_KEYS), Setup (pfColumnIndex_, pfFindSheetByKey_).
- **Import.js** — центральный узел импорта: использует Schema, Constants, ErrorHandler, Sheets, Settings, CategoryRules (pfApplyCategoryRules_), DateUtils (pfISOStringToDate_, pfFormatDateForDedupe_ и др.).
- Глобальные сущности **PF_SHEET_KEYS**, **PF_SETUP_KEYS**, **PF_NAMED_RANGES**, **pfColumnIndex_** определены в **I18n.js** и **Setup.js**. Порядок загрузки файлов в Apps Script определяется порядком в проекте; явного списка в appsscript.json нет — возможны риски порядка инициализации.

**Рекомендация:** Зафиксировать и задокументировать порядок загрузки (например, в README или отдельном ARCHITECTURE.md): сначала константы/схема, затем I18n/Sheets/Setup/Settings, затем модули данных и UI.

---

## 3. Выявленные проблемы

### 3.1. Критические и логические ошибки

#### 3.1.1. Запись диапазона в RawSheets.js (батч-запись)

**Файл:** `src/RawSheets.js`, цикл записи чанками.

**Проблема:** В цикле используется:

```javascript
var range = txSheet.getRange(chunkStartRow, 1, numRowsInChunk, numCols);
range.setValues(chunk);
```

Сигнатура `getRange(row, column, numRows, numColumns)` в Google Apps Script корректна: записывается ровно `numRowsInChunk` строк начиная с `chunkStartRow`. **Но** после цикла форматирование применяется один раз ко всему блоку:

```javascript
txSheet.getRange(startRow, dateCol, numRows, 1).setNumberFormat('dd.mm.yyyy');
```

Здесь третий аргумент — `numRows` (общее число записанных строк). Диапазон получается от `startRow` на `numRows` строк и 1 столбец — это **верно**. Следует явно проверить на тестовых данных, что формат применяется ко **всем** добавленным строкам (включая все чанки), а не только к первому диапазону. При возможном изменении логики чанков легко ошибиться.

**Рекомендация:** Вынести применение формата в цикл по чанкам или один раз после цикла с явным комментарием, что `startRow` и `numRows` относятся ко всему объёму записанных данных. Добавить юнит/интеграционный тест: записать 2–3 чанка и проверить, что у всех строк колонки даты/суммы/SourceId заданы нужные форматы.

---

#### 3.1.2. Дедупликация при синхронизации raw (исправлено в документации, проверить в коде)

**Файл:** `src/RawSheets.js`.

В `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md` указано, что при совпадении ключа с существующей транзакцией строку **не** нужно добавлять в лист «Транзакции». В текущей реализации при `alreadyOnSheet` выполняется `result.skipped++; continue;` и строка **не** попадает в `allNewRows` — поведение корректное. Следует убедиться, что ни в одной ветке такая строка не пушится в `allNewRows` со статусом `needs_review` (иначе дубликаты появятся в таблице).

**Рекомендация:** Один раз пройти код RawSheets по сценарию «ключ уже есть на листе» и зафиксировать в тесте: при совпадении (Source, SourceId) новая строка не добавляется, только увеличивается `result.skipped`.

---

#### 3.1.3. Чтение данных при коммите импорта (Import.js)

**Файл:** `src/Import.js`, функция `pfCommitImport_`.

**Код:** `var data = stagingSheet.getRange(2, 1, stagingLastRow - 1, numDataCols).getValues();`

В Google Apps Script `getRange(row, column, numRows, numColumns)` — третий параметр это **число строк**. То есть читаются строки с 2 по `2 + (stagingLastRow - 1) - 1 = stagingLastRow`. Количество строк в `data` равно `stagingLastRow - 1`. При `stagingLastRow = 11` (10 строк данных) получаем 10 строк — **корректно**. Для ясности и во избежание путаницы лучше ввести переменную `numDataRows = stagingLastRow - 1` и использовать её в getRange и в комментарии.

**Рекомендация:** Необязательно, но полезно: ввести `numDataRows` и использовать в getRange(2, 1, numDataRows, numDataCols) и в комментарии «читаем numDataRows строк данных».

---

#### 3.1.4. Очистка строк листа (Sheets.js)

**Файл:** `src/Sheets.js`, функция `pfClearSheetRows_(sheet, startRow, numRows)`.

**Код:** `var clearRange = sheet.getRange(startRow, 1, numRows, lastCol);`

Сигнатура: `getRange(startRow, 1, numRows, lastCol)` — диапазон из `numRows` строк и `lastCol` столбцов, начиная с (startRow, 1). Очищаются строки `startRow … startRow + numRows - 1`. Затем вызывается `sheet.deleteRows(startRow, numRows)`. Логика совпадает. **Замечание:** после `clearContent()` и `clearFormat()` удаление строк может в отдельных сценариях (например, защищённые листы) выбросить исключение — обработка уже есть (fallback без удаления). Оставить как есть, при необходимости добавить в документацию ограничения.

---

#### 3.1.5. Валидация и подсветка строки (Validation.js)

**Файл:** `src/Validation.js`.

Используется `sheet.getRange(rowNum, 1, 1, PF_TRANSACTIONS_SCHEMA.columns.length)` — одна строка, все колонки схемы. Сигнатура соблюдена. Ошибок не выявлено.

---

### 3.2. Мёртвый код

#### 3.2.1. Устаревшие функции импорта (Import.js)

- **pfProcessFileImport_(fileContent, options)** — помечена как `@deprecated`, в теле — `throw new Error(...)`. Нигде не вызывается. Можно удалить после проверки поиском по репозиторию.
- **pfProcessImportData_(rawData, importer, options)** — аналогично, `@deprecated`, не используется. Можно удалить.

**Рекомендация:** Удалить обе функции в рамках задачи «Очистка мёртвого кода» (см. план ниже). Перед удалением: поиск по коду и тестам по именам функций.

---

#### 3.2.2. Дублирование сообщения в UI (Code.js)

**Файл:** `src/Code.js`, функция `pfSyncRawSheetsToTransactionsMenu`.

Сообщение пользователю формируется вручную в зависимости от `pfGetLanguage_()`. При этом в `result` уже нет «добавлено как needs_review» для дубликатов (дубликаты не добавляются), но текст сообщения всё ещё содержит вариант «Добавлено со статусом «На проверку» (возможные дубликаты)» при `result.skipped > 0`. Имеет смысл формулировку скорректировать: например, «Пропущено (уже есть в Транзакциях): N», чтобы не вводить в заблуждение.

**Рекомендация:** Обновить тексты в `pfSyncRawSheetsToTransactionsMenu` под актуальную логику (skipped = пропущенные дубликаты, без добавления в таблицу). При желании вынести строки в I18n.

---

### 3.3. Несогласованности и стиль

#### 3.3.1. Локализация меню (Code.js)

**Файл:** `src/Code.js`.

Пункт меню «Запустить тесты» задан строкой `'Запустить тесты'` и не использует `pfT_()`. Остальные пункты переведены через I18n. Это нарушает единообразие локализации.

**Рекомендация:** Добавить ключ в I18n (например, `menu.run_tests`) для RU/EN и заменить строку на `pfT_('menu.run_tests')`.

---

#### 3.3.2. Хардкод строк в предпросмотре импорта (Import.js)

**Файл:** `src/Import.js`, функция `pfPreviewImport_`.

В примечании к ячейке используется строка: «Дубликат. Ключ: … Используйте меню "Personal finances → Найти дубликат"». Текст захардкожен на русском и не использует i18n.

**Рекомендация:** Вынести в I18n (например, ключи для сообщения о дубликате и подсказки по меню) и подставлять через `pfT_()`.

---

#### 3.3.3. Единый ключ дедупликации (Raw vs Import)

**Файлы:** `src/RawSheets.js`, `src/Import.js`.

- Raw: ключ формируется как `source + ':' + sourceId` (source = `raw:ИмяЛиста`, sourceId = функция из даты/времени/суммы/номера строки).
- Import: используется `pfGenerateDedupeKey_(data, options)` — для объекта с `source`/`sourceId` возвращается `source + ':' + sourceId`; при отсутствии sourceId — хэш по дате/счёту/сумме/типу.

Для raw и импорта с явным sourceId логика согласована. Для ручных строк и edge-cases важно, чтобы везде, где проверяется «уже есть в Транзакциях», использовалась одна и та же функция формирования ключа (как сейчас в Import через `pfGenerateDedupeKey_`). В RawSheets ключ строится вручную (`tx.source + ':' + tx.sourceId`), что эквивалентно. Для будущего расширения лучше вызывать общую функцию (например, обёртку над `source + ':' + sourceId`) из одного места, чтобы не разъехались форматы.

**Рекомендация:** Долгосрочно — ввести одну функцию «канонического ключа» (например, в Import.js или в отдельном Dedupe.js) и использовать её в RawSheets и Import. Краткосрочно — оставить как есть, но зафиксировать в коде комментарий, что ключ должен совпадать с `pfGenerateDedupeKey_` для объектов с source/sourceId.

---

### 3.4. Производительность и объём данных

#### 3.4.1. Загрузка ключей транзакций (Import.js)

**Файл:** `src/Import.js`, функция `pfGetExistingTransactionKeys_()`.

Реализована чанковая обработка при >10000 строк и оптимизация «читать только нужные колонки». Для очень больших листов стоит проверить лимиты времени выполнения (6 мин у обычного пользователя) и при необходимости уменьшить размер чанка или добавить кэширование (например, по дате последнего изменения листа). Это уже отмечено в PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md.

**Рекомендация:** Оставить как есть; при появлении жалоб на таймауты — профилировать и рассмотреть кэш или триггер с записью ключей во временный лист/свойства.

---

#### 3.4.2. Автокатегоризация при импорте (Import.js)

В коде отключена автокатегоризация для PDF из-за производительности (`pfGetAllCategoryRules_` медленная). Для CSV/других форматов она выполняется. Имеет смысл либо оптимизировать получение правил (кэш, индексация), либо вынести применение категорий в отдельный шаг после импорта.

**Рекомендация:** В плане рефакторинга выделить задачу «Оптимизация автокатегоризации» (кэш правил, батч-применение после коммита).

---

### 3.5. Надёжность и граничные случаи

#### 3.5.1. Поиск дубликата (Import.js)

**Файл:** `src/Import.js`, функция `pfFindDuplicateTransaction(dedupeKey)`.

Используется `txSheet.getRange(2, 1, txSheet.getLastRow() - 1, PF_TRANSACTIONS_SCHEMA.columns.length)`. При `getLastRow() === 2` (одна строка данных) третий параметр будет 1 — читается одна строка. При `getLastRow() === 1` получится 0 строк — массив пустой. Поведение корректно. Дополнительно: валидация ключа и проверка наличия двоеточия уже есть.

**Рекомендация:** Оставить без изменений; при расширении сценариев добавить тесты на пустой лист и одну строку.

---

#### 3.5.2. Список счетов для импорта (Import.js)

**Файл:** `src/Import.js`, функция `pfGetAccountsList()`.

Используется `accountsSheet.getRange(2, accountCol, accountsSheet.getLastRow() - 1, 1).getValues()`. При одном столбце и `getLastRow() - 1` строк данные считываются верно. Обработка пустого листа и отсутствия листа есть.

**Рекомендация:** Без изменений.

---

### 3.6. Документация и поддержка

- В `docs/` уже есть несколько перекрестных документов (PROTOTYPE_REVIEW, RAW_SHEETS_ARCHITECTURE, CODE_REVIEW, EXPERT_REVIEW, TECHNICAL_SPECIFICATION и др.). Часть информации дублируется.
- Порядок загрузки файлов Apps Script и зависимости между глобальными объектами нигде явно не описаны.

**Рекомендация:** Свести в один «архитектурный» документ (или раздел в README): список файлов, порядок инициализации, основные глобальные объекты и откуда они берутся. Ссылки на детальные спецификации (RAW_SHEETS, TRANSACTIONS_SCHEMA, TECHNICAL_SPECIFICATION) оставить.

---

## 4. Возможные пути решения (сводка)

| Категория | Подход |
|-----------|--------|
| Критические/логические ошибки | Проверить форматирование в RawSheets после записи чанков; зафиксировать тестами сценарий дедупликации raw; при желании ввести `numDataRows` в pfCommitImport_. |
| Мёртвый код | Удалить deprecated-функции после поиска по репозиторию; обновить сообщения в меню raw под актуальную логику skipped. |
| Несогласованности | Вынести в I18n пункт «Запустить тесты» и строки в предпросмотре импорта; долгосрочно — единая функция ключа дедупликации. |
| Производительность | При необходимости — кэш ключей/правил категорий, чанки, отложенная автокатегоризация. |
| Надёжность | Добавить тесты на граничные случаи (пустой лист, одна строка, дубликаты raw). |
| Документация | Один обзорный документ по структуре и зависимостям кода. |

---

## 5. Подробный план рефакторинга (по шагам)

План рассчитан на передачу разработчикам и продакт-менеджеру. Изменения в код **не вносились**; ниже — только описание шагов.

---

### Этап 0. Подготовка (обязательно перед любыми изменениями)

| Шаг | Действие | Комментарий |
|-----|----------|-------------|
| 0.1 | Сделать резервную копию репозитория и (при необходимости) тестовой таблицы | Чтобы можно было откатиться после рефакторинга. |
| 0.2 | Зафиксировать текущее поведение: сценарии «синхронизация raw», «импорт CSV/PDF», «коммит импорта», «поиск дубликата» | Кратко описать или записать тест-кейсы; после рефакторинга пройти их снова. |
| 0.3 | Убедиться, что все тесты (например, `pfRunAllTests`) проходят | Базовый уровень перед изменениями. |

---

### Этап 1. Критические проверки и мелкие исправления

| № | Задача | Где | Подробное описание |
|---|--------|-----|--------------------|
| 1.1 | Проверить применение формата при синхронизации raw | RawSheets.js | После цикла записи чанков вызывается setNumberFormat для даты, суммы и SourceId от startRow на numRows строк. Убедиться по тестовым данным (например, 2 чанка по 100 строк), что формат применён ко всем 200 строкам. При необходимости добавить комментарий в коде и простой тест. |
| 1.2 | Подтвердить отсутствие добавления дубликатов raw в Транзакции | RawSheets.js | Пройти код: при alreadyOnSheet выполняется только result.skipped++; continue; строка не попадает в allNewRows. Добавить юнит/ручной тест: дважды синхронизировать один и тот же raw-лист — во второй раз добавлено 0, skipped = количество строк. |
| 1.3 | Уточнить сообщение после синхронизации raw | Code.js | В pfSyncRawSheetsToTransactionsMenu изменить формулировку при result.skipped > 0 на что-то вроде «Пропущено (уже в Транзакциях): N» (RU/EN через I18n), убрав упоминание «добавлено как needs_review». |
| 1.4 | (Опционально) Явная переменная числа строк при коммите импорта | Import.js | В pfCommitImport_ ввести numDataRows = stagingLastRow - 1 и использовать в getRange(2, 1, numDataRows, numDataCols) и в комментарии для ясности. |

---

### Этап 2. Удаление мёртвого кода

| № | Задача | Где | Подробное описание |
|---|--------|-----|--------------------|
| 2.1 | Удалить pfProcessFileImport_ | Import.js | Убедиться поиском по репозиторию (включая тесты и HTML), что функция нигде не вызывается. Удалить объявление функции целиком. При наличии ссылок в документации — обновить. |
| 2.2 | Удалить pfProcessImportData_ | Import.js | Аналогично: поиск по коду и тестам, удаление функции. Обновить комментарии/документацию, если упоминается. |

---

### Этап 3. Локализация и единообразие

| № | Задача | Где | Подробное описание |
|---|--------|-----|--------------------|
| 3.1 | Локализовать пункт меню «Запустить тесты» | Code.js, I18n.js | В I18n.js добавить ключ menu.run_tests для ru и en. В Code.js заменить 'Запустить тесты' на pfT_('menu.run_tests'). |
| 3.2 | Локализовать текст примечания о дубликате в предпросмотре | Import.js, I18n.js | Добавить ключи для текста «Дубликат. Ключ: …» и подсказки по меню «Найти дубликат». В pfPreviewImport_ подставлять строки через pfT_(). |

---

### Этап 4. Единый ключ дедупликации (низкий приоритет)

| № | Задача | Где | Подробное описание |
|---|--------|-----|--------------------|
| 4.1 | Вынести формирование ключа в одну функцию | Import.js или новый Dedupe.js | Создать функцию вида pfCanonicalDedupeKey_(tx), возвращающую source + ':' + (sourceId || hash). В RawSheets при проверке existingOnSheet и добавлении в addedInThisRun использовать эту функцию для объекта tx. В Import везде, где строится ключ из объекта транзакции, вызывать ту же функцию. Документировать в коде, что ключ дедупликации должен быть единым. |

---

### Этап 5. Тесты и граничные случаи

| № | Задача | Где | Подробное описание |
|---|--------|-----|--------------------|
| 5.1 | Тесты для RawSheets | test/ или src/Tests.js | Юнит-тесты: парсинг даты/времени/суммы (pfParseRawDate_, pfNormalizeRawTime_, pfParseRawAmount_), формирование SourceId (pfRawSourceId_), логика «не добавлять при уже существующем ключе» (можно мокать pfGetExistingTransactionKeys_). |
| 5.2 | Ручной сценарий «новый пользователь» | docs/TESTING_CHECKLIST.md или аналог | Пошагово: Setup → создание raw-листа с тестовыми данными → Синхронизация с raw-листами → проверка листа Транзакции (количество, форматы) → повторная синхронизация (0 добавлено, N пропущено) → Обновить отчёты/дашборд. Зафиксировать в чеклисте. |
| 5.3 | Граничные случаи поиска дубликата | Import.js / тесты | Тест: пустой лист Транзакции; одна строка; ключ с разным регистром/пробелами (если применимо). При необходимости доработать валидацию ключа. |

---

### Этап 6. Документация и архитектура

| № | Задача | Где | Подробное описание |
|---|--------|-----|--------------------|
| 6.1 | Документ «Структура и зависимости кода» | docs/ARCHITECTURE_AND_DEPS.md или раздел в README | Описать: список основных файлов и их роль; откуда берутся PF_SHEET_KEYS, PF_SETUP_KEYS, PF_NAMED_RANGES, pfColumnIndex_, pfGetSetting_; рекомендуемый порядок файлов (если влияет на clasp); ссылки на RAW_SHEETS_ARCHITECTURE, TRANSACTIONS_SCHEMA, TECHNICAL_SPECIFICATION. |
| 6.2 | Ссылка на план рефакторинга | README или индекс docs/ | Добавить в README или в индекс документации ссылку на настоящий документ (REFACTORING_PLAN_FOR_PM.md) и кратко указать, что это план для PM и разработки без внесения изменений на момент даты документа. |

---

### Этап 7. Долгосрочные улучшения (по приоритету продукта)

Эти пункты можно планировать отдельно от основного рефакторинга; они уже частично отражены в PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md.

| № | Задача | Краткое описание |
|---|--------|------------------|
| 7.1 | Мультивалютность | Лист «Курсы валют», пересчёт в базовую валюту в отчётах и дашборде (TECHNICAL_SPECIFICATION, Этап 4). |
| 7.2 | Документация для пользователя | В Help раздел «Как добавить новый счёт (raw-лист)»: имя листа, пример заголовков и 1–2 строк, порядок действий. |
| 7.3 | Опциональный маппинг форматов raw | Лист Raw_Config для других форматов выписок (RAW_SHEETS_ARCHITECTURE, п. 3.3). |
| 7.4 | Остатки по счетам на дашборде | Блок «Остатки по счетам» на листе Дашборд. |
| 7.5 | Выбор периода дашборда | Параметр месяц/квартал и пересчёт KPI/графиков за выбранный период. |
| 7.6 | Id и аудит в схеме транзакций | Опционально: колонки Id, CreatedAt, UpdatedAt; миграция существующих строк. |
| 7.7 | Оптимизация автокатегоризации | Кэш правил, батч-применение после коммита, включение для PDF при приемлемой скорости. |

---

## 6. Приоритизация для реализации

| Приоритет | Этапы | Комментарий |
|-----------|--------|-------------|
| Высокий | 0, 1 | Подготовка и проверка критичных мест (формат raw, дедупликация, сообщения). |
| Средний | 2, 3, 5.1–5.2 | Удаление мёртвого кода, локализация, базовые тесты и чеклист. |
| Низкий | 4, 5.3, 6 | Единый ключ дедупликации, дополнительные тесты, документация структуры. |
| По бэклогу | 7 | Мультивалютность, Raw_Config, дашборд и т.д. — в зависимости от дорожной карты продукта. |

---

## 7. Ссылки на существующие документы

- Архитектура raw-листов: `docs/RAW_SHEETS_ARCHITECTURE.md`
- Схема транзакций: `docs/TRANSACTIONS_SCHEMA.md`
- Техническое задание (этапы): `docs/TECHNICAL_SPECIFICATION.md`
- Анализ прототипа и план переработки: `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md`
- Ревью кода: `docs/CODE_REVIEW.md`
- Текущее состояние: `docs/PROJECT_STATE.md`
- Код: `src/RawSheets.js`, `src/Code.js`, `src/Import.js`, `src/Validation.js`, `src/Sheets.js`, `src/Setup.js`, `src/I18n.js` и др.

---

**Документ готов к передаче продакт-менеджеру и команде разработки для планирования спринтов и выполнения рефакторинга.**

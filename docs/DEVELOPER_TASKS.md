# Задачи для разработчиков: доработка инструмента учёта личных финансов

**Дата:** 31 января 2026  
**Назначение:** Список независимых задач для параллельной разработки. Основано на ревью финансиста (`PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md`) и программиста-архитектора (`REFACTORING_PLAN_FOR_PM.md`).

**Ссылка на таблицу-прототип:**  
https://docs.google.com/spreadsheets/d/18Ae4ovzy2y3dsHW_NHxOvRt8h7NAJHqrb60S4pvurUI/edit?gid=1728027484#gid=1728027484

---

## Как пользоваться документом

- **Задачи с номерами 1–15** можно выполнять **параллельно** разными разработчиками (зависимости указаны в блоке «Зависимости» внутри задачи).
- В каждой задаче: цель, файлы, пошаговые действия, критерии приёмки, ссылки на документы.
- Перед началом любых изменений выполните **Подготовку (общий этап 0)** один раз на команду.

---

## Подготовка (общий этап 0) — выполнить один раз перед спринтом

| Шаг | Действие | Детали |
|-----|----------|--------|
| 0.1 | Резервная копия | Сделать бэкап репозитория и (при необходимости) тестовой Google-таблицы. |
| 0.2 | Фиксация поведения | Кратко зафиксировать сценарии: «синхронизация raw», «импорт CSV/PDF», «коммит импорта», «поиск дубликата». После рефакторинга пройти их снова. |
| 0.3 | Прогон тестов | Убедиться, что все тесты (например, `pfRunAllTests`) проходят. Базовый уровень перед изменениями. |

---

## Задача 1. RawSheets: проверка форматирования и дедупликации

**Приоритет:** Высокий  
**Файлы:** `src/RawSheets.js`, при необходимости `test/` или `src/Tests.js`  
**Зависимости:** Нет. Можно выполнять параллельно с остальными задачами.

### Цель

Убедиться, что при синхронизации raw-листов: (1) формат даты/суммы/SourceId применяется ко **всем** добавленным строкам (включая все чанки); (2) при совпадении ключа (Source, SourceId) с существующей транзакцией новая строка **не** добавляется в лист «Транзакции» (только `result.skipped++`).

### Пошаговые действия

1. **Проверить логику дедупликации в коде**
   - Открыть `src/RawSheets.js`.
   - Найти цикл по строкам raw-листа. При `alreadyOnSheet === true` должно выполняться только `result.skipped++; continue;` — строка не должна попадать в `allNewRows`.
   - Убедиться, что ни в одной ветке при `alreadyOnSheet` строка не пушится в `allNewRows` со статусом `needs_review` (иначе в таблице появятся дубликаты).
   - Если найдётся добавление дубликата в `allNewRows` — удалить эту ветку.

2. **Проверить применение формата после записи чанков**
   - После цикла записи чанков вызывается:
     - `txSheet.getRange(startRow, dateCol, numRows, 1).setNumberFormat('dd.mm.yyyy');`
     - `txSheet.getRange(startRow, amountCol, numRows, 1).setNumberFormat('0.00');`
     - `txSheet.getRange(startRow, sourceIdCol, numRows, 1).setNumberFormat('@');`
   - В Google Apps Script `getRange(row, column, numRows, numColumns)`: третий аргумент — число строк. Диапазон: от `startRow` на `numRows` строк, 1 столбец. Убедиться, что `startRow` и `numRows` относятся ко **всему** объёму записанных данных (сумма по всем чанкам).
   - Добавить в коде явный комментарий: «Формат применяется ко всем добавленным строкам (startRow … startRow + numRows - 1)».

3. **Ручная проверка на тестовых данных**
   - Создать raw-лист с тестовыми данными (например, 250 строк). При размере чанка 500 будет один чанк; при 100 — несколько. Либо временно уменьшить константу чанка для теста.
   - Запустить «Синхронизировать с raw-листами». Проверить, что у **всех** добавленных строк: колонка даты в формате dd.mm.yyyy, сумма — число с двумя знаками, SourceId — текст (@).
   - Повторно запустить синхронизацию. Ожидаемо: добавлено 0, пропущено (skipped) = количество строк. В листе «Транзакции» не должно появиться дублей.

4. **Опционально: автоматический тест**
   - В `test/` или `src/Tests.js` добавить тест: при совпадении (Source, SourceId) с уже существующей транзакцией новая строка не добавляется, только увеличивается `result.skipped`. При возможности замокать `pfGetExistingTransactionKeys_` или использовать тестовую таблицу.

### Критерии приёмки

- [ ] При уже существующем ключе (Source, SourceId) строка не добавляется в «Транзакции»; только `result.skipped++`.
- [ ] Формат даты, суммы и SourceId применён ко всем новым строкам (в т.ч. при записи несколькими чанками).
- [ ] В коде есть комментарий о диапазоне форматирования.
- [ ] Ручной сценарий (два запуска синхронизации без дублей) выполнен.

### Ссылки

- `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md` — п. 5.1, 4.2  
- `docs/REFACTORING_PLAN_FOR_PM.md` — п. 3.1.1, 3.1.2, этап 1.1–1.2  
- `docs/RAW_SHEETS_ARCHITECTURE.md`

---

## Задача 2. Сообщение после синхронизации raw (UI)

**Приоритет:** Высокий  
**Файлы:** `src/Code.js`, `src/I18n.js`  
**Зависимости:** Нет. Можно выполнять параллельно с задачей 1.

### Цель

Текст после «Синхронизировать с raw-листами» должен соответствовать фактическому поведению: при `result.skipped > 0` — «Пропущено (уже в Транзакциях): N», без упоминания «добавлено как needs_review» (дубликаты больше не добавляются).

### Пошаговые действия

1. **Добавить ключи в I18n**
   - В `src/I18n.js` в объектах `PF_I18N.ru` и `PF_I18N.en` (в блоке `menu` или создать блок `sync_raw`) добавить ключи, например:
     - `sync_raw_result_added`: «Добавлено» / "Added"
     - `sync_raw_result_skipped`: «Пропущено (уже в Транзакциях)» / "Skipped (already in Transactions)"
     - Или один ключ для целой фразы результата с плейсхолдерами.
   - Формат сообщения: «Обработано листов: X. Добавлено: Y. Пропущено (уже в Транзакциях): Z» (если Z > 0).

2. **Обновить формирование сообщения в Code.js**
   - В `src/Code.js` найти функцию `pfSyncRawSheetsToTransactionsMenu`.
   - Заменить хардкод строк на вызовы `pfT_()` с новыми ключами. При `result.skipped > 0` выводить фразу вида «Пропущено (уже в Транзакциях): N», не «Добавлено со статусом «На проверку» (возможные дубликаты)».
   - Сохранить вывод ошибок (`result.errors`) без изменений.

3. **Проверить оба языка**
   - Переключить язык в настройках на EN, запустить синхронизацию и проверить сообщение на английском.

### Критерии приёмки

- [ ] При skipped > 0 отображается «Пропущено (уже в Транзакциях): N» (RU) и эквивалент на EN.
- [ ] Нет упоминания «добавлено как needs_review» или «possible duplicates» в контексте skipped.
- [ ] Строки вынесены в I18n, используются через `pfT_()`.

### Ссылки

- `docs/REFACTORING_PLAN_FOR_PM.md` — п. 3.2.2, этап 1.3

---

## Задача 3. Удаление устаревших функций импорта (мёртвый код)

**Приоритет:** Средний  
**Файлы:** `src/Import.js`  
**Зависимости:** Нет. Можно выполнять параллельно с остальными.

### Цель

Удалить неиспользуемые deprecated-функции `pfProcessFileImport_` и `pfProcessImportData_`, чтобы уменьшить путаницу и объём кода.

### Пошаговые действия

1. **Проверить отсутствие вызовов**
   - По всему репозиторию (включая `src/`, `test/`, HTML-файлы) выполнить поиск по строкам `pfProcessFileImport_` и `pfProcessImportData_`.
   - Убедиться, что функции нигде не вызываются (только объявление и, возможно, упоминание в комментариях/документации).

2. **Удалить pfProcessFileImport_**
   - В `src/Import.js` найти объявление функции `pfProcessFileImport_` (помечена `@deprecated`, в теле `throw new Error(...)`).
   - Удалить функцию целиком (включая JSDoc).

3. **Удалить pfProcessImportData_**
   - Аналогично найти и удалить функцию `pfProcessImportData_` в `src/Import.js`.

4. **Обновить документацию**
   - В `docs/CODE_REVIEW.md`, `docs/PROJECT_STATE.md` и других файлах, где упоминаются эти функции, убрать или скорректировать формулировки (например, «удалены в рамках рефакторинга»).

### Критерии приёмки

- [ ] В коде нет объявлений `pfProcessFileImport_` и `pfProcessImportData_`.
- [ ] Поиск по репозиторию не находит вызовов этих функций.
- [ ] Документация обновлена при необходимости.

### Ссылки

- `docs/REFACTORING_PLAN_FOR_PM.md` — п. 3.2.1, этап 2

---

## Задача 4. Локализация пункта меню «Запустить тесты»

**Приоритет:** Средний  
**Файлы:** `src/Code.js`, `src/I18n.js`  
**Зависимости:** Нет.

### Цель

Пункт меню «Запустить тесты» переведён через I18n (как остальные пункты), а не захардкожен строкой `'Запустить тесты'`.

### Пошаговые действия

1. В `src/I18n.js` в объектах `PF_I18N.ru.menu` и `PF_I18N.en.menu` добавить ключ, например: `run_tests: 'Запустить тесты'` (ru), `run_tests: 'Run tests'` (en).
2. В `src/Code.js` найти место, где добавляется пункт меню для тестов (поиск по строке `'Запустить тесты'`), и заменить на `pfT_('menu.run_tests')`.
3. Проверить отображение пункта при языках RU и EN.

### Критерии приёмки

- [ ] Ключ `menu.run_tests` присутствует в RU и EN.
- [ ] В Code.js используется только `pfT_('menu.run_tests')`, хардкода нет.

### Ссылки

- `docs/REFACTORING_PLAN_FOR_PM.md` — п. 3.3.1, этап 3.1

---

## Задача 5. Локализация текста о дубликате в предпросмотре импорта

**Приоритет:** Средний  
**Файлы:** `src/Import.js`, `src/I18n.js`  
**Зависимости:** Нет.

### Цель

Текст примечания в ячейке при предпросмотре импорта («Дубликат. Ключ: … Используйте меню "Personal finances → Найти дубликат"») вынести в I18n и подставлять через `pfT_()`.

### Пошаговые действия

1. В `src/Import.js` найти функцию `pfPreviewImport_` и строку с текстом про дубликат и подсказку по меню «Найти дубликат».
2. В `src/I18n.js` добавить ключи, например:
   - `import.duplicate_note`: «Дубликат. Ключ: {key}» / "Duplicate. Key: {key}"
   - `import.duplicate_hint`: «Используйте меню "Personal finances → Найти дубликат"» / "Use menu 'Personal finances → Find duplicate'"  
   (или один ключ с плейсхолдером, если в проекте есть поддержка подстановки в `pfT_`).
3. В `pfPreviewImport_` формировать текст примечания через `pfT_()`, подставляя ключ/параметры. Учесть, что в Apps Script может не быть интерполяции в `pfT_` — тогда можно передавать ключ и отдельно ключ, а строку собирать как `pfT_('import.duplicate_note') + ' ' + key + ' ' + pfT_('import.duplicate_hint')`.
4. Проверить предпросмотр импорта с дубликатом при RU и EN.

### Критерии приёмки

- [ ] Нет хардкода русского/английского текста о дубликате в Import.js.
- [ ] Тексты берутся из I18n, отображаются корректно на обоих языках.

### Ссылки

- `docs/REFACTORING_PLAN_FOR_PM.md` — п. 3.3.2, этап 3.2

---

## Задача 6. Явная переменная числа строк при коммите импорта

**Приоритет:** Низкий  
**Файлы:** `src/Import.js`  
**Зависимости:** Нет.

### Цель

Улучшить читаемость и однозначность кода в `pfCommitImport_`: явно ввести переменную `numDataRows` для числа строк данных и использовать её в `getRange` и в комментарии.

### Пошаговые действия

1. В `src/Import.js` найти функцию `pfCommitImport_`.
2. Найти строку вида:  
   `var data = stagingSheet.getRange(2, 1, stagingLastRow - 1, numDataCols).getValues();`  
   Уточнить по коду: в Google Apps Script `getRange(row, column, numRows, numColumns)` — третий параметр это число строк. То есть сейчас читаются строки с 2 по `2 + (stagingLastRow - 1) - 1` — т.е. интерпретация может отличаться. По текущей логике: количество строк данных = `stagingLastRow - 1` (если последняя занятая строка — stagingLastRow, то данных — до неё включительно, т.е. от 2 до stagingLastRow — это stagingLastRow - 1 строк). Ввести `var numDataRows = stagingLastRow - 1;`.
3. Заменить вызов на `stagingSheet.getRange(2, 1, numDataRows, numDataCols)` — **внимание:** в getRange третий аргумент это numRows, т.е. количество строк. Диапазон «со 2-й строки, numDataRows строк» задаётся как `getRange(2, 1, numDataRows, numDataCols)` (начало строки 2, число строк numDataRows). Проверить документацию Google: getRange(startRow, startColumn, numRows, numColumns). Тогда вызов корректен: getRange(2, 1, numDataRows, numDataCols).
4. Добавить краткий комментарий: «Читаем numDataRows строк данных (со 2-й строки листа импорта)».

### Критерии приёмки

- [ ] Переменная `numDataRows` введена и используется в getRange.
- [ ] Поведение не изменилось (тест: коммит импорта даёт те же данные в «Транзакции»).
- [ ] Комментарий добавлен.

### Ссылки

- `docs/REFACTORING_PLAN_FOR_PM.md` — п. 3.1.3, этап 1.4

---

## Задача 7. Единая функция ключа дедупликации

**Приоритет:** Низкий  
**Файлы:** `src/Import.js`, при необходимости новый `src/Dedupe.js`; `src/RawSheets.js`  
**Зависимости:** Желательно выполнять после задач 1 и 3, чтобы не пересекаться с изменениями в RawSheets и Import. Можно выполнять параллельно с задачами 2, 4, 5, 6.

### Цель

Иметь одну каноническую функцию формирования ключа дедупликации (source + ':' + sourceId или с fallback на хэш), использовать её в RawSheets и в Import, чтобы форматы не разъехались при изменениях.

### Пошаговые действия

1. Определить место функции: в `src/Import.js` уже есть `pfGenerateDedupeKey_(data, options)`. Решение: вынести в общую функцию (например, в Import.js оставить обёртку, вызывающую общую, или создать Dedupe.js с одной функцией и подключать в обоих модулях). Учитывая отсутствие в Apps Script явного модульного импорта, проще всего добавить в Import.js функцию вида `pfCanonicalDedupeKey_(tx)`, где `tx` — объект с полями `source`, `sourceId` (и при отсутствии sourceId — дата, счёт, сумма, тип для хэша). В RawSheets вызывать эту функцию, если она доступна глобально (файл Import.js загружается раньше RawSheets в проекте — проверить порядок в appsscript.json или списке файлов).
2. В `src/Import.js` реализовать `pfCanonicalDedupeKey_(tx)`: возвращать `tx.source + ':' + (tx.sourceId || hash(tx))` в соответствии с текущей логикой `pfGenerateDedupeKey_` для объектов с source/sourceId. Привести внутренние вызовы в Import к использованию этой функции там, где ключ строится из объекта транзакции.
3. В `src/RawSheets.js` в месте формирования ключа для проверки `existingOnSheet` и для `addedInThisRun` заменить ручную конкатенацию `tx.source + ':' + tx.sourceId` на вызов `pfCanonicalDedupeKey_(tx)` (если имя глобальное). Убедиться, что объект `tx` имеет поля `source` и `sourceId`.
4. В коде или в документации (например, в TRANSACTIONS_SCHEMA.md или в комментарии в Import.js) кратко зафиксировать: «Ключ дедупликации формируется единой функцией pfCanonicalDedupeKey_; Raw и Import должны использовать её для согласованности.»

### Критерии приёмки

- [ ] Одна функция формирует ключ для дедупликации.
- [ ] RawSheets и Import используют эту функцию; дубликаты по-прежнему корректно определяются.
- [ ] Ручной тест: импорт и raw с одним и тем же source/sourceId не создают двух строк.

### Ссылки

- `docs/REFACTORING_PLAN_FOR_PM.md` — п. 3.3.3, этап 4

---

## Задача 8. Документация для пользователя: «Как добавить новый счёт (raw-лист)»

**Приоритет:** Средний  
**Файлы:** `src/Help.js` (или место, где формируется содержимое Инструкции), при необходимости отдельный раздел в листе «Инструкция»  
**Зависимости:** Нет. Можно выполнять параллельно с остальными.

### Цель

В справку (Help / Инструкция) добавить пошаговый раздел «Как добавить новый счёт (новый raw-лист)»: требования к имени листа, пример заголовков и 1–2 строк данных, порядок действий (создать лист → заполнить → Синхронизировать с raw-листами).

### Пошаговые действия

1. Определить, где хранится текст справки: лист «Инструкция» (Help), генерируется ли он из кода (Help.js) или это статический текст в шаблоне/документации.
2. Добавить раздел с заголовком типа «Как добавить новый счёт (raw-лист)» и подпунктами:
   - Имя листа должно начинаться с `raw` (например, `raw_Сбербанк`, `raw_Яндекс Карта`). Один лист = один счёт.
   - Обязательные колонки в первой строке (заголовки): ДАТА, ВРЕМЯ, КАТЕГОРИЯ, ОПИСАНИЕ, СУММА, ОСТАТОК СРЕДСТВ, СЧЕТ — в этом порядке. См. `docs/RAW_SHEETS_ARCHITECTURE.md`, п. 3.2.
   - Формат: дата dd.mm.yyyy, сумма — число (минус = расход, плюс = доход). Если колонка СЧЕТ пустая, подставится имя листа.
   - Пример 1–2 строк данных (можно скопировать из RAW_SHEETS_ARCHITECTURE или придумать короткий пример).
   - Порядок действий: создать лист с именем raw_… → вставить заголовки → заполнить данные → меню «Personal finances → Синхронизировать с raw-листами».
3. Если справка локализована (RU/EN), добавить эквивалент на английском.
4. При наличии списка разделов в начале Инструкции — добавить туда ссылку/пункт на новый раздел.

### Критерии приёмки

- [ ] В справке есть раздел с явным названием про добавление нового счёта (raw-лист).
- [ ] Описаны имя листа, порядок колонок, пример данных, шаги синхронизации.
- [ ] Ссылка на RAW_SHEETS_ARCHITECTURE или эквивалент информации включена.

### Ссылки

- `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md` — п. 5.2, задача 4  
- `docs/RAW_SHEETS_ARCHITECTURE.md` — п. 3.1–3.2

---

## Задача 9. Документ «Структура и зависимости кода»

**Приоритет:** Низкий  
**Файлы:** новый файл `docs/ARCHITECTURE_AND_DEPS.md`, при желании обновить `README.md`  
**Зависимости:** Нет. Можно выполнять параллельно с остальными.

### Цель

Иметь один обзорный документ для разработчиков: список основных файлов и их роль, откуда берутся глобальные объекты (PF_SHEET_KEYS, PF_SETUP_KEYS, PF_NAMED_RANGES, pfColumnIndex_, pfGetSetting_), рекомендуемый порядок загрузки файлов (если влияет на clasp), ссылки на детальные спецификации.

### Пошаговые действия

1. Создать `docs/ARCHITECTURE_AND_DEPS.md`.
2. Включить разделы:
   - **Основные файлы и роль:** таблица или список (Code.js — точка входа; Schema.js, Constants.js — схемы и константы; I18n.js, Sheets.js, Setup.js, Settings.js — листы и настройки; RawSheets.js, Import.js, ImportCsv.js, … — данные; Validation.js, ErrorHandler.js; Dashboard.js, Reports.js, Budgets.js, …; вспомогательные DateUtils, Export, Archive, Help, Template и т.д.). Кратко 1–2 предложения на файл.
   - **Глобальные объекты и источник:** PF_SHEET_KEYS, PF_SETUP_KEYS, PF_NAMED_RANGES — из I18n/Setup; pfColumnIndex_, pfFindSheetByKey_ — из Setup; pfGetSetting_ — из Settings; PF_TRANSACTIONS_SCHEMA — из Schema. Указать файл, где что объявлено.
   - **Порядок загрузки:** пояснить, что в Google Apps Script порядок файлов в проекте может влиять на инициализацию. Рекомендуемый порядок: константы/схема → I18n, Sheets, Setup, Settings → модули данных и UI. Ссылка на appsscript.json или список файлов в проекте.
   - **Ссылки на детальные документы:** RAW_SHEETS_ARCHITECTURE.md, TRANSACTIONS_SCHEMA.md, TECHNICAL_SPECIFICATION.md, PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md, REFACTORING_PLAN_FOR_PM.md.
3. В README.md или в начале docs добавить ссылку на ARCHITECTURE_AND_DEPS.md и кратко указать назначение (обзор структуры и зависимостей для разработки).

### Критерии приёмки

- [ ] Файл ARCHITECTURE_AND_DEPS.md создан и содержит перечисленные разделы.
- [ ] Ссылка на документ добавлена в README или индекс документации.

### Ссылки

- `docs/REFACTORING_PLAN_FOR_PM.md` — п. 3.6, этап 6.1–6.2

---

## Задача 10. Тесты для RawSheets (парсинг и дедупликация)

**Приоритет:** Средний  
**Файлы:** `test/` (например, `raw-sheets.test.js`) или `src/Tests.js`  
**Зависимости:** Нет. Можно выполнять параллельно с задачей 1 (но после задачи 1 логика дедупликации уже проверена вручную).

### Цель

Автоматические тесты для парсинга даты/времени/суммы, формирования SourceId и сценария «при существующем ключе строка не добавляется».

### Пошаговые действия

1. Создать файл тестов (например, `test/raw-sheets.test.js` или добавить блок в `src/Tests.js`). Учесть, что в среде Google Apps Script тесты часто запускают через `pfRunAllTests`; если используется внешний раннер (Node), адаптировать под него (моки для SpreadsheetApp и т.д.).
2. **Юнит-тесты парсинга:**
   - `pfParseRawDate_`: строка dd.mm.yyyy → Date; невалидная строка / null → null; объект Date → тот же Date.
   - `pfNormalizeRawTime_`: строка "16:40" → "1640"; число (доля дня) → "hhmm"; null/undefined → "0000".
   - Парсинг суммы (функция, которая по знаку определяет тип и возвращает положительную сумму): отрицательное число → expense, положительное → income, сумма по модулю.
3. **SourceId:** функция формирования SourceId (например, `pfRawSourceId_` или аналог): по дате, времени, сумме, номеру строки — стабильная строка без пробелов/запятых. Проверить, что одинаковые входы дают один и тот же SourceId.
4. **Дедупликация:** при наличии мока для существующих ключей (или тестовой таблицы): если ключ уже есть в `existingOnSheet`, новая строка не попадает в массив добавляемых; счётчик skipped увеличивается. При необходимости вызвать внутреннюю функцию синхронизации с подставленным набором existingOnSheet.
5. Задокументировать в README или в docs, как запускать тесты (например, через меню «Запустить тесты» в таблице).

### Критерии приёмки

- [ ] Есть тесты на парсинг даты, времени, суммы (и тип по знаку).
- [ ] Есть тест на формирование SourceId.
- [ ] Есть тест на поведение при уже существующем ключе (не добавлять, увеличить skipped).
- [ ] Тесты проходят в выбранной среде (меню в таблице или npm-скрипт).

### Ссылки

- `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md` — п. 5.5, задача 10  
- `docs/REFACTORING_PLAN_FOR_PM.md` — этап 5.1

---

## Задача 11. Ручной сценарий «новый пользователь» и чеклист

**Приоритет:** Средний  
**Файлы:** `docs/TESTING_CHECKLIST.md` (или аналог)  
**Зависимости:** Нет. Можно выполнять параллельно с остальными.

### Цель

Зафиксировать в чеклисте пошаговый сценарий: Setup → создание raw-листа с тестовыми данными → Синхронизация с raw-листами → проверка листа «Транзакции» (количество, форматы) → повторная синхронизация (0 добавлено, N пропущено) → Обновить отчёты/дашборд.

### Пошаговые действия

1. Открыть `docs/TESTING_CHECKLIST.md` (или создать, если нужен отдельный чеклист для raw).
2. Добавить раздел «Сценарий: новый пользователь и raw-листы» (или «Тест: синхронизация raw-листов») с шагами:
   - Запустить **Personal finances → Setup (создать листы)**.
   - Создать лист с именем `raw_Тест` (или аналогичным). Первая строка: заголовки ДАТА, ВРЕМЯ, КАТЕГОРИЯ, ОПИСАНИЕ, СУММА, ОСТАТОК СРЕДСТВ, СЧЕТ. Вторая и третья строки: 2–3 тестовые транзакции (дата dd.mm.yyyy, сумма с минусом/плюсом).
   - Запустить **Personal finances → Синхронизировать с raw-листами**.
   - Проверить: в листе «Транзакции» появились новые строки; колонки Дата, Сумма, ID источника отформатированы; количество добавленных совпадает с сообщением.
   - Запустить синхронизацию ещё раз. Ожидаемо: «Добавлено: 0», «Пропущено (уже в Транзакциях): N» (N = число строк с raw-листа).
   - Запустить **Обновить отчёты** и **Обновить дашборд**. Убедиться, что данные отображаются без ошибок.
3. Сохранить чеклист в виде списка галочек [ ] для повторного прохождения после изменений.

### Критерии приёмки

- [ ] В TESTING_CHECKLIST (или отдельном файле) есть описанный сценарий с чекбоксами.
- [ ] Сценарий покрывает Setup, создание raw, два запуска синхронизации, отчёты и дашборд.

### Ссылки

- `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md` — п. 5.5, задача 11  
- `docs/REFACTORING_PLAN_FOR_PM.md` — этап 5.2

---

## Задача 12. Мультивалютность (лист «Курсы валют», пересчёт в отчётах и дашборде)

**Приоритет:** По бэклогу продукта (высокий, если нужна мультивалютность)  
**Файлы:** `src/Schema.js`, `src/Setup.js`, новый `src/ExchangeRates.js` (или аналог), `src/Settings.js`, `src/Reports.js`, `src/Dashboard.js`, `src/Code.js`  
**Зависимости:** Крупная задача; лучше выполнять отдельным спринтом. Не блокирует задачи 1–11.

### Цель

Реализовать лист «Курсы валют» (дата, валюта, курс к базовой), пересчёт сумм в базовую валюту в отчётах и на дашборде по курсу на дату транзакции; KPI и графики в базовой валюте.

### Пошаговые действия

1. **Схема и лист**
   - В `Schema.js` добавить схему листа ExchangeRates (или Курсы валют): Date, Currency, Rate, Source (опционально). В `Setup.js` — создание листа, заголовки, форматирование.
2. **Модуль курсов**
   - Создать модуль (например, `ExchangeRates.js`) с функциями: инициализация листа, `pfGetExchangeRate_(currency, date)` — курс валюты на дату (поиск по листу; если базовая валюта — 1), `pfConvertToBaseCurrency_(amount, currency, date)` — пересчёт в базовую. Базовая валюта брать из Settings (добавить настройку BaseCurrency, по умолчанию RUB).
3. **Settings**
   - В `Settings.js` и листе «Настройки» добавить ключ BaseCurrency, чтение/запись.
4. **Reports**
   - В `Reports.js` при расчёте сумм по транзакциям: для каждой транзакции с валютой, отличной от базовой, пересчитать сумму в базовую по курсу на дату транзакции. Добавить при необходимости колонку «В базовой валюте» или показывать итоги в базовой валюте.
5. **Dashboard**
   - В `Dashboard.js` KPI (доходы, расходы, средний расход в день и т.д.) считать в базовой валюте; графики также в базовой валюте. Учесть переводы (transfer) — не дублировать суммы.
6. **Меню**
   - В `Code.js` добавить пункт «Обновить курсы валют» (опционально — вызов API ЦБ РФ или ручной ввод). Локализовать через I18n.
7. **Документация и тесты**
   - Обновить TECHNICAL_SPECIFICATION.md (Этап 4) при расхождениях. Ручные тесты: несколько транзакций в USD/EUR, курсы на даты, проверка отчётов и дашборда в RUB.

### Критерии приёмки

- [ ] Лист «Курсы валют» создаётся при Setup; можно вводить курсы вручную.
- [ ] В Reports и Dashboard суммы пересчитываются в базовую валюту по курсу на дату транзакции.
- [ ] KPI и графики отображаются в базовой валюте.
- [ ] Базовая валюта настраивается в Settings.

### Ссылки

- `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md` — п. 5.2, задача 3; п. 3.2  
- `docs/TECHNICAL_SPECIFICATION.md` — Этап 4 (п. 4.1–4.7)

---

## Задача 13. Остатки по счетам на дашборде

**Приоритет:** По бэклогу (улучшение UX)  
**Файлы:** `src/Dashboard.js`, при необходимости `src/Reports.js` (переиспользовать логику расчёта остатков)  
**Зависимости:** Нет. Можно выполнять параллельно с задачами, не затрагивающими Dashboard.

### Цель

На листе «Дашборд» добавить блок «Остатки по счетам»: счёт — сумма (текущий остаток). Логика расчёта — та же, что в отчётах (начальный баланс + транзакции + переводы).

### Пошаговые действия

1. В `Reports.js` найти функцию/блок, где считаются остатки по счетам (начальный баланс, учёт транзакций и переводов). Вынести в общую функцию получения остатков по счетам (например, `pfGetAccountBalances_(ss)` или аналог), если такой ещё нет.
2. В `Dashboard.js` в месте построения виджетов дашборда добавить секцию «Остатки по счетам». Вызвать функцию расчёта остатков, сформировать таблицу или список: имя счёта — сумма. Разместить блок на листе «Дашборд» (например, в заданной области или под существующими KPI).
3. Обновить обновление дашборда по кнопке «Обновить дашборд», чтобы этот блок пересчитывался вместе с остальными.
4. Локализовать заголовок блока (например, «Остатки по счетам» / "Account balances") через I18n.
5. При желании добавить ссылку/подсказку «подробнее в Отчётах».

### Критерии приёмки

- [ ] На дашборде отображается блок с остатками по каждому счёту.
- [ ] Расчёт совпадает с логикой в отчётах (начальный баланс + транзакции + переводы).
- [ ] Блок обновляется по кнопке «Обновить дашборд».

### Ссылки

- `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md` — п. 5.3, задача 6; п. 3.3

---

## Задача 14. Выбор периода для дашборда (опционально)

**Приоритет:** Низкий / по бэклогу  
**Файлы:** `src/Dashboard.js`, `src/Settings.js` или лист «Параметры»/«Настройки», `src/Code.js`  
**Зависимости:** Нет. Можно выполнять параллельно с задачей 13.

### Цель

Дать пользователю возможность выбрать месяц (или квартал) для дашборда и пересчитывать KPI и графики за выбранный период, а не только за «текущий месяц» и «последние 12 месяцев».

### Пошаговые действия

1. Определить место хранения параметра: лист «Настройки» (новый ключ, например DashboardMonth), или отдельный лист «Параметры дашборда» с одной ячейкой (месяц/квартал в формате YYYY-MM или YYYY-Qn).
2. В `Dashboard.js` при расчёте KPI и при построении графиков читать выбранный период; если не задан — использовать текущий месяц (как сейчас). Пересчитать доходы/расходы, средний расход в день, топ категорий, динамику по месяцам за выбранный период (или период, включающий выбранный месяц).
3. UI для выбора: выпадающий список на листе «Дашборд» или в настройках (список месяцев за последние 12–24 месяца). Обновление дашборда по кнопке — перечитать период и пересчитать.
4. Локализовать подписи (месяц, квартал, «текущий месяц»).

### Критерии приёмки

- [ ] Можно выбрать месяц (или квартал) для отображения на дашборде.
- [ ] KPI и графики пересчитываются за выбранный период.
- [ ] При отсутствии выбора поведение как раньше (текущий месяц).

### Ссылки

- `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md` — п. 5.3, задача 7; п. 3.3

---

## Задача 15. Опциональный маппинг форматов raw (Raw_Config)

**Приоритет:** Низкий (реализовать при появлении второго формата выписок)  
**Файлы:** `src/Schema.js`, `src/Setup.js`, `src/RawSheets.js`, документация  
**Зависимости:** Требует понимания текущего формата raw (задача 1 и RAW_SHEETS_ARCHITECTURE). Можно выполнять после задач 1 и 8.

### Цель

Ввести лист **Raw_Config** (или аналог) с маппингом: имя raw-листа → соответствие колонок полям канонической схемы (Date, Amount, Description, Account и т.д.), чтобы поддерживать выписки с другими порядками колонок или заголовками.

### Пошаговые действия

1. Описать в `docs/RAW_SHEETS_ARCHITECTURE.md` (п. 3.3) формат листа Raw_Config: например, колонки SheetName, RawColumnIndex, CanonicalField (или RawHeader, CanonicalField). Один вариант: для каждого листа указать маппинг заголовок_raw → поле_схемы.
2. В `Schema.js` добавить схему листа Raw_Config; в `Setup.js` — создание листа при необходимости (опционально, не ломать существующие таблицы без Raw_Config).
3. В `RawSheets.js` при чтении raw-листа: если для имени листа есть строка в Raw_Config, использовать маппинг колонок; иначе — текущая фиксированная схема (A=ДАТА, B=ВРЕМЯ, …). Реализовать чтение по маппингу (по индексу или по заголовку).
4. Тестирование: создать второй raw-лист с другим порядком колонок (например, СУММА в первой колонке), заполнить Raw_Config, синхронизировать и проверить, что данные попали в «Транзакции» с правильными полями.
5. Документация для пользователя: в разделе Help про raw-листы добавить подпункт «Другой формат выписки» с описанием Raw_Config.

### Критерии приёмки

- [ ] Лист Raw_Config описан и при наличии используется при синхронизации.
- [ ] Без Raw_Config поведение как раньше (фиксированные 7 колонок).
- [ ] С Raw_Config можно задать другой порядок/названия колонок для выбранного raw-листа.

### Ссылки

- `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md` — п. 5.2, задача 5  
- `docs/RAW_SHEETS_ARCHITECTURE.md` — п. 3.3

---

## Сводная таблица задач и параллельности

| №   | Задача                                      | Приоритет | Параллельно с      | Основные файлы        |
|-----|---------------------------------------------|-----------|--------------------|------------------------|
| 1   | RawSheets: форматирование и дедупликация    | Высокий   | 2–11               | RawSheets.js          |
| 2   | Сообщение после синхронизации raw           | Высокий   | 1, 3–11            | Code.js, I18n.js       |
| 3   | Удаление мёртвого кода (Import)             | Средний   | 1, 2, 4–11         | Import.js             |
| 4   | Локализация «Запустить тесты»              | Средний   | 1–3, 5–11          | Code.js, I18n.js       |
| 5   | Локализация текста о дубликате в импорте    | Средний   | 1–4, 6–11          | Import.js, I18n.js     |
| 6   | Переменная numDataRows в коммите импорта    | Низкий    | 1–5, 7–11          | Import.js             |
| 7   | Единая функция ключа дедупликации           | Низкий    | 2–6, 8–11          | Import.js, RawSheets.js|
| 8   | Документация «Как добавить новый счёт»      | Средний   | 1–7, 9–11          | Help.js / лист        |
| 9   | Документ ARCHITECTURE_AND_DEPS              | Низкий    | 1–8, 10–11         | docs/                  |
| 10  | Тесты для RawSheets                         | Средний   | 1–9, 11            | test/, Tests.js        |
| 11  | Ручной сценарий и чеклист                   | Средний   | 1–10               | docs/TESTING_CHECKLIST |
| 12  | Мультивалютность                            | Бэклог    | 1–11               | Schema, Setup, новый модуль, Reports, Dashboard |
| 13  | Остатки по счетам на дашборде                | Бэклог    | 1–12               | Dashboard.js, Reports.js |
| 14  | Выбор периода дашборда                      | Бэклог    | 1–13               | Dashboard.js, Settings |
| 15  | Raw_Config (маппинг форматов raw)           | Низкий    | 1–11               | RawSheets.js, Schema, Setup |

---

## Рекомендуемый порядок выполнения (если не параллельно)

1. **Сначала:** подготовка (этап 0), затем задачи **1** и **2** (критичные для raw).
2. **Далее:** задачи **3, 4, 5, 8, 10, 11** (очистка кода, локализация, тесты, документация).
3. **Затем:** задачи **6, 7, 9** (уточнения кода, единый ключ, архитектурный документ).
4. **По бэклогу продукта:** задачи **12, 13, 14, 15** (мультивалютность, дашборд, Raw_Config).

---

*Документ подготовлен для передачи команде разработки. Исходные ревью: финансист — `docs/PROTOTYPE_REVIEW_AND_IMPLEMENTATION_PLAN.md`, программист-архитектор — `docs/REFACTORING_PLAN_FOR_PM.md`.*

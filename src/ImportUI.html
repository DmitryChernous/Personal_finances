<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 10px;
      margin: 0;
    }
    h2 {
      margin-top: 0;
      font-size: 16px;
    }
    .section {
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    input[type="file"] {
      width: 100%;
      margin-bottom: 10px;
    }
    select, input[type="text"] {
      width: 100%;
      padding: 5px;
      margin-bottom: 10px;
      box-sizing: border-box;
    }
    button {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      background-color: #4285f4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background-color: #357ae8;
    }
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .stats {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    .stats-item {
      margin: 5px 0;
    }
    .error {
      color: #d32f2f;
      font-size: 12px;
      margin-top: 5px;
    }
    .success {
      color: #388e3c;
      font-size: 12px;
      margin-top: 5px;
    }
    .info {
      background-color: #e3f2fd;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h2>Импорт транзакций</h2>
  
  <div class="info">
    Поддерживаемые форматы: CSV, Excel (через экспорт в CSV).<br>
    PDF файлы: экспортируйте в CSV/Excel перед импортом.
  </div>
  
  <div class="section">
    <label for="fileInput">Выберите файл:</label>
    <input type="file" id="fileInput" accept=".csv,.txt" style="width: 100%; margin-bottom: 5px;">
    <div id="fileInfo" style="font-size: 12px; color: #666; margin-top: 5px;"></div>
  </div>
  
  <div class="section">
    <label for="defaultAccount">Счет по умолчанию:</label>
    <select id="defaultAccount">
      <option value="">-- Выберите счет --</option>
    </select>
  </div>
  
  <div class="section">
    <label for="defaultCurrency">Валюта по умолчанию:</label>
    <select id="defaultCurrency">
      <option value="RUB">RUB</option>
      <option value="USD">USD</option>
      <option value="EUR">EUR</option>
    </select>
  </div>
  
  <div class="section">
    <button id="previewBtn" onclick="handlePreview()">Предпросмотр</button>
    <button id="commitBtn" onclick="handleCommit()" disabled>Импортировать</button>
    <button id="commitWithReviewBtn" onclick="handleCommitWithReview()" disabled>Импортировать (включая на проверку)</button>
  </div>
  
  <div id="stats" class="stats" style="display: none;">
    <div class="stats-item"><strong>Статистика:</strong></div>
    <div class="stats-item">Всего: <span id="statTotal">0</span></div>
    <div class="stats-item">Валидных: <span id="statValid">0</span></div>
    <div class="stats-item">На проверку: <span id="statReview">0</span></div>
    <div class="stats-item">Дубликатов: <span id="statDuplicates">0</span></div>
  </div>
  
  <div id="message"></div>
  
  <div id="progress" style="display: none; margin-top: 10px;">
    <div style="background-color: #f0f0f0; border-radius: 4px; padding: 10px;">
      <div style="font-weight: bold; margin-bottom: 5px;">Обработка файла...</div>
      <div id="progressText" style="font-size: 12px; color: #666;">Инициализация...</div>
      <div style="background-color: #e0e0e0; border-radius: 2px; height: 20px; margin-top: 5px; overflow: hidden;">
        <div id="progressBar" style="background-color: #4285f4; height: 100%; width: 0%; transition: width 0.3s;"></div>
      </div>
    </div>
  </div>
  
  <script>
    var fileContent = null;
    var previewData = null;
    
    // Load accounts on page load
    window.onload = function() {
      loadAccounts();
      
      // Handle file input
      document.getElementById('fileInput').addEventListener('change', function(e) {
        var file = e.target.files[0];
        if (file) {
          document.getElementById('message').innerHTML = '<div>Загрузка файла...</div>';
          document.getElementById('previewBtn').disabled = true;
          
          var reader = new FileReader();
          reader.onload = function(e) {
            try {
              fileContent = e.target.result;
              if (fileContent && fileContent.length > 0) {
                document.getElementById('fileInfo').textContent = 'Файл: ' + file.name + ' (' + fileContent.length + ' символов)';
                document.getElementById('message').innerHTML = 
                  '<div class="success">Файл загружен: ' + file.name + ' (' + fileContent.length + ' символов)</div>';
                // Reset preview
                previewData = null;
                document.getElementById('previewBtn').disabled = false;
                document.getElementById('commitBtn').disabled = true;
                document.getElementById('commitWithReviewBtn').disabled = true;
                document.getElementById('stats').style.display = 'none';
              } else {
                showError('Файл пуст или не удалось прочитать содержимое');
                document.getElementById('fileInfo').textContent = '';
                document.getElementById('previewBtn').disabled = true;
                fileContent = null;
              }
            } catch (err) {
              showError('Ошибка при чтении файла: ' + err.message);
              document.getElementById('fileInfo').textContent = '';
              document.getElementById('previewBtn').disabled = true;
              fileContent = null;
            }
          };
          reader.onerror = function(e) {
            showError('Ошибка при чтении файла. Код ошибки: ' + (e.target.error ? e.target.error.code : 'unknown'));
            document.getElementById('fileInfo').textContent = '';
            document.getElementById('previewBtn').disabled = true;
            fileContent = null;
          };
          reader.readAsText(file, 'UTF-8');
        } else {
          fileContent = null;
          document.getElementById('fileInfo').textContent = '';
          document.getElementById('previewBtn').disabled = true;
          document.getElementById('message').innerHTML = '';
        }
      });
    };
    
    function loadAccounts() {
      google.script.run
        .withSuccessHandler(function(accounts) {
          var select = document.getElementById('defaultAccount');
          accounts.forEach(function(account) {
            var option = document.createElement('option');
            option.value = account;
            option.text = account;
            select.appendChild(option);
          });
        })
        .withFailureHandler(function(error) {
          console.error('Error loading accounts:', error);
        })
        .pfGetAccountsList_();
    }
    
    function handlePreview() {
      // Check if file is selected
      var fileInput = document.getElementById('fileInput');
      if (!fileInput.files || fileInput.files.length === 0) {
        showError('Сначала выберите файл');
        return;
      }
      
      // If fileContent is not set, try to read it again
      if (!fileContent) {
        var file = fileInput.files[0];
        if (file) {
          var reader = new FileReader();
          reader.onload = function(e) {
            fileContent = e.target.result;
            if (fileContent) {
              // Retry preview
              handlePreview();
            } else {
              showError('Не удалось прочитать содержимое файла');
            }
          };
          reader.onerror = function() {
            showError('Ошибка при чтении файла');
          };
          reader.readAsText(file, 'UTF-8');
          return; // Wait for file to be read
        } else {
          showError('Сначала выберите файл');
          return;
        }
      }
      
      var defaultAccount = document.getElementById('defaultAccount').value;
      var defaultCurrency = document.getElementById('defaultCurrency').value;
      
      document.getElementById('previewBtn').disabled = true;
      document.getElementById('message').innerHTML = '<div>Обработка файла...</div>';
      
      // Process in steps with real progress
      processImportWithProgress(fileContent, defaultAccount, defaultCurrency);
    }
    
    function handleCommit() {
      commitImport(false);
    }
    
    function handleCommitWithReview() {
      commitImport(true);
    }
    
    function commitImport(includeNeedsReview) {
      if (!previewData) {
        showError('Сначала выполните предпросмотр');
        return;
      }
      
      document.getElementById('commitBtn').disabled = true;
      document.getElementById('commitWithReviewBtn').disabled = true;
      document.getElementById('message').innerHTML = '<div>Импорт...</div>';
      
      google.script.run
        .withSuccessHandler(function(result) {
          if (result.success) {
            document.getElementById('message').innerHTML = 
              '<div class="success">' + result.message + '</div>';
            // Reset
            previewData = null;
            document.getElementById('fileInput').value = '';
            fileContent = null;
            document.getElementById('stats').style.display = 'none';
            document.getElementById('commitBtn').disabled = true;
            document.getElementById('commitWithReviewBtn').disabled = true;
          } else {
            showError(result.message);
            document.getElementById('commitBtn').disabled = false;
            document.getElementById('commitWithReviewBtn').disabled = false;
          }
        })
        .withFailureHandler(function(error) {
          showError('Ошибка при импорте: ' + error.message);
          document.getElementById('commitBtn').disabled = false;
          document.getElementById('commitWithReviewBtn').disabled = false;
        })
        .pfCommitImport_(includeNeedsReview);
    }
    
    function showStats(stats) {
      document.getElementById('statTotal').textContent = stats.total;
      document.getElementById('statValid').textContent = stats.valid;
      document.getElementById('statReview').textContent = stats.needsReview;
      document.getElementById('statDuplicates').textContent = stats.duplicates;
      document.getElementById('stats').style.display = 'block';
    }
    
    function showError(message) {
      document.getElementById('message').innerHTML = 
        '<div class="error">' + message + '</div>';
    }
    
    function showProgress(text, percent) {
      document.getElementById('progress').style.display = 'block';
      document.getElementById('progressText').textContent = text;
      document.getElementById('progressBar').style.width = percent + '%';
    }
    
    function updateProgress(text, percent) {
      document.getElementById('progressText').textContent = text;
      document.getElementById('progressBar').style.width = percent + '%';
    }
    
    function hideProgress() {
      document.getElementById('progress').style.display = 'none';
      document.getElementById('progressBar').style.width = '0%';
    }
    
    /**
     * Process import in steps with real progress updates.
     */
    function processImportWithProgress(fileContent, defaultAccount, defaultCurrency) {
      var options = {
        defaultAccount: defaultAccount,
        defaultCurrency: defaultCurrency
      };
      
      // Step 1: Detect format (5%)
      showProgress('Определение формата файла...', 5);
      google.script.run
        .withSuccessHandler(function(formatInfo) {
          if (!formatInfo.detected) {
            hideProgress();
            showError('Формат файла не поддерживается. Используйте CSV файл или выписку Сбербанка.');
            document.getElementById('previewBtn').disabled = false;
            return;
          }
          
          // Step 2: Parse file (5-30%)
          updateProgress('Парсинг файла...', 10);
          google.script.run
            .withSuccessHandler(function(parseResult) {
              if (parseResult.count === 0) {
                hideProgress();
                showError('Файл пуст или не содержит данных для импорта');
                document.getElementById('previewBtn').disabled = false;
                return;
              }
              
              updateProgress('Найдено транзакций: ' + parseResult.count + '. Обработка данных...', 15);
              
              // Step 3: Process data in batches
              processDataInBatches(parseResult.rawData, formatInfo.importerType, options, parseResult.count);
            })
            .withFailureHandler(function(error) {
              hideProgress();
              showError('Ошибка при парсинге файла: ' + (error.message || error.toString()));
              document.getElementById('previewBtn').disabled = false;
            })
            .pfParseFileContent(fileContent, formatInfo.importerType, options);
        })
        .withFailureHandler(function(error) {
          hideProgress();
          showError('Ошибка при определении формата: ' + (error.message || error.toString()));
          document.getElementById('previewBtn').disabled = false;
        })
        .pfDetectFileFormat(fileContent);
    }
    
    /**
     * Process data in batches with progress updates.
     */
    function processDataInBatches(rawData, importerType, options, totalCount) {
      var allTransactions = [];
      var totalStats = {
        valid: 0,
        needsReview: 0,
        duplicates: 0,
        errors: 0
      };
      var batchSize = 200;
      var processed = 0;
      var existingKeys = null; // Store deduplication keys across batches
      var timeoutId = null;
      
      // Store total count in options for server-side function
      options._totalCount = totalCount;
      
      // Load existing keys ONCE before processing batches (to avoid calling slow function on each batch)
      console.log('[CLIENT] Starting to load existing keys...');
      updateProgress('Загрузка существующих транзакций для проверки дубликатов...', 16);
      
      var keysLoadStartTime = Date.now();
      google.script.run
        .withSuccessHandler(function(keys) {
          var keysLoadDuration = Date.now() - keysLoadStartTime;
          console.log('[CLIENT] Keys loaded successfully in', keysLoadDuration, 'ms');
          console.log('[CLIENT] Keys count:', keys ? Object.keys(keys).length : 0);
          existingKeys = keys || {};
          // Start processing batches
          console.log('[CLIENT] Starting first batch processing...');
          processNextBatch();
        })
        .withFailureHandler(function(error) {
          var keysLoadDuration = Date.now() - keysLoadStartTime;
          console.error('[CLIENT] Failed to load keys after', keysLoadDuration, 'ms');
          console.error('[CLIENT] Keys load error:', error);
          // If loading keys fails, start with empty keys (will still work, just won't detect duplicates with existing)
          console.warn('[CLIENT] Starting with empty keys due to error');
          existingKeys = {};
          processNextBatch();
        })
        .pfGetExistingTransactionKeys();
      
      console.log('[CLIENT] pfGetExistingTransactionKeys call initiated');
      
      return; // Don't call processNextBatch() here - it will be called after keys are loaded
      
      function processNextBatch() {
        console.log('[CLIENT] processNextBatch called, processed:', processed, 'totalCount:', totalCount);
        
        // Clear any existing timeout
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        
        if (processed >= totalCount) {
          console.log('[CLIENT] All processed, writing preview');
          // All processed, write preview
          writePreview();
          return;
        }
        
        // Calculate progress (17% to 85%) - adjusted because keys loading takes 1-2%
        var progress = 17 + Math.floor((processed / totalCount) * 68);
        var remaining = totalCount - processed;
        updateProgress('Обработка транзакций: ' + processed + ' из ' + totalCount + ' (' + remaining + ' осталось)...', progress);
        
        // Extract only the batch we need (not the entire array)
        var batchEnd = Math.min(processed + batchSize, totalCount);
        var batchData = rawData.slice(processed, batchEnd);
        
        console.log('[CLIENT] Batch data extracted:', {
          processed: processed,
          batchEnd: batchEnd,
          batchSize: batchData.length,
          totalCount: totalCount,
          existingKeysCount: existingKeys ? Object.keys(existingKeys).length : 0
        });
        
        // Process batch - pass only the batch data, not entire array
        // Also pass current processed count and existing keys so server knows the offset
        var batchOptions = Object.assign({}, options);
        batchOptions._startIndex = processed;
        // Always pass existingKeys (loaded once at the beginning)
        batchOptions._existingKeys = existingKeys || {};
        
        console.log('[CLIENT] Calling pfProcessDataBatch with:', {
          batchDataLength: batchData.length,
          importerType: importerType,
          batchSize: batchSize,
          processed: processed,
          optionsKeys: Object.keys(batchOptions)
        });
        
        // Set timeout (5 minutes)
        timeoutId = setTimeout(function() {
          console.error('[CLIENT] TIMEOUT after 5 minutes!');
          hideProgress();
          showError('Таймаут при обработке (5 минут). Попробуйте уменьшить размер файла или разбить его на части.');
          document.getElementById('previewBtn').disabled = false;
        }, 300000);
        
        var callStartTime = Date.now();
        console.log('[CLIENT] Starting google.script.run.pfProcessDataBatch at', new Date().toISOString());
        
        google.script.run
          .withSuccessHandler(function(batchResult) {
            var callDuration = Date.now() - callStartTime;
            console.log('[CLIENT] pfProcessDataBatch SUCCESS after', callDuration, 'ms');
            console.log('[CLIENT] Batch result received:', batchResult);
            console.log('[CLIENT] Batch result type:', typeof batchResult);
            console.log('[CLIENT] Batch result is null?', batchResult === null);
            console.log('[CLIENT] Batch result is undefined?', batchResult === undefined);
            
            // Check if result is null or invalid
            if (!batchResult || typeof batchResult !== 'object') {
              console.error('[CLIENT] ERROR: batchResult is null or invalid!', batchResult);
              hideProgress();
              showError('Ошибка: сервер вернул неверный результат. Попробуйте уменьшить размер батча или разбить файл на части.');
              document.getElementById('previewBtn').disabled = false;
              return;
            }
            
            console.log('[CLIENT] Batch result details:', {
              transactionsCount: batchResult.transactions ? batchResult.transactions.length : 'MISSING',
              stats: batchResult.stats,
              processed: batchResult.processed,
              total: batchResult.total,
              hasMore: batchResult.hasMore,
              existingKeysCount: batchResult.existingKeys ? Object.keys(batchResult.existingKeys).length : 0
            });
            
            if (!batchResult.transactions || !Array.isArray(batchResult.transactions)) {
              console.error('[CLIENT] ERROR: batchResult.transactions is missing or not an array!', batchResult.transactions);
              hideProgress();
              showError('Ошибка: сервер вернул результат без транзакций. Попробуйте уменьшить размер батча.');
              document.getElementById('previewBtn').disabled = false;
              return;
            }
            
            if (timeoutId) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            
            allTransactions = allTransactions.concat(batchResult.transactions);
            totalStats.valid += batchResult.stats.valid;
            totalStats.needsReview += batchResult.stats.needsReview;
            totalStats.duplicates += batchResult.stats.duplicates;
            totalStats.errors += batchResult.stats.errors;
            processed = batchResult.processed;
            
            console.log('[CLIENT] Updated totals:', {
              allTransactionsCount: allTransactions.length,
              totalStats: totalStats,
              processed: processed
            });
            
            // Update existing keys for next batch
            if (batchResult.existingKeys) {
              existingKeys = batchResult.existingKeys;
            }
            
            // Continue with next batch
            if (batchResult.hasMore) {
              console.log('[CLIENT] Has more batches, continuing...');
              setTimeout(processNextBatch, 50); // Small delay to allow UI update
            } else {
              console.log('[CLIENT] No more batches, writing preview');
              // All processed, write preview
              writePreview();
            }
          })
          .withFailureHandler(function(error) {
            var callDuration = Date.now() - callStartTime;
            console.error('[CLIENT] pfProcessDataBatch FAILED after', callDuration, 'ms');
            console.error('[CLIENT] Error details:', error);
            console.error('[CLIENT] Error message:', error.message);
            console.error('[CLIENT] Error stack:', error.stack);
            
            if (timeoutId) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            hideProgress();
            var errorMsg = 'Ошибка при обработке данных (строка ' + (processed + 1) + '): ' + 
                          (error.message || error.toString());
            if (error.stack) {
              errorMsg += '\nДетали: ' + error.stack.substring(0, 500);
            }
            showError(errorMsg);
            document.getElementById('previewBtn').disabled = false;
          })
          .pfProcessDataBatch(JSON.stringify(batchData), importerType, batchOptions, batchSize, processed);
        
        console.log('[CLIENT] google.script.run.pfProcessDataBatch call initiated');
      }
      
      function writePreview() {
        updateProgress('Запись предпросмотра в таблицу...', 90);
        google.script.run
          .withSuccessHandler(function(preview) {
            hideProgress();
            previewData = preview;
            preview.stats.total = allTransactions.length;
            preview.stats.valid = totalStats.valid;
            preview.stats.needsReview = totalStats.needsReview;
            preview.stats.duplicates = totalStats.duplicates;
            showStats(preview.stats);
            document.getElementById('message').innerHTML = 
              '<div class="success">Предпросмотр готов. Проверьте лист "' + preview.stagingSheetName + '"</div>';
            document.getElementById('previewBtn').disabled = false;
            document.getElementById('commitBtn').disabled = false;
            document.getElementById('commitWithReviewBtn').disabled = false;
          })
          .withFailureHandler(function(error) {
            hideProgress();
            showError('Ошибка при создании предпросмотра: ' + (error.message || error.toString()));
            document.getElementById('previewBtn').disabled = false;
          })
          .pfWritePreview(JSON.stringify(allTransactions));
      }
      
      // Note: processNextBatch() will be called after keys are loaded
      // (see the google.script.run.pfGetExistingTransactionKeys_() call above)
    }
  </script>
</body>
</html>
